1. Storage

    a. variables in the main program

    Variables in the main program will be allocated as an activation record at the beginning of the stack. This way, nested scopes can easily access these "global" variables by simply using the display at 0. These variables will the simply be put in order as they are declared. This way accessing variables need only be counting the total amount of space of variables beforehand. In addition, these variables must be assigned their default values. We will use DUPN to initialize these so we have fewer instructions than a series of PUSH 0 commands.

    Example code:

    {
        var x, y[3] : integer   % 1.a.1

        function f : integer {
            return with y[2] % a.2
        }
    }

    Generated code (specifically for the variable portion):

    PUSH 0  % 1.a.1
    PUSH 4  % 1.a.1
    DUPN    % 1.a.1

    These can easily be accessed by any scope using commands similar to (the last argument will vary):

    ADDR 0 3    % 1.a.2

    b. variables in procedures and functions

    Variables in routines will be handled similarly to the main program. That is, when an activation record starts, variable values will simply be pushed onto the stack (see 1.a for details). Accessing these variables can be performed similar to those in the main program, however the "lexical level" argument must be specified at compile time based on the depth of the function declaration. When leaving the routine, these variables will be popped off.

    Example code:
    
    {
        var x, y[3] : integer

        function f : integer {
            var z : integer
            return with z % 1.b.1
        }
    }

    Generated code for accessing:

    ADDR 1 0    % 1.b.1
    
    c. variables in minor scopes

    Minor scopes will be handled just the same as the routine scopes, with the added understanding that an explicit activation record will not be created. The variables of the minor scope will just be pushed onto the stack atop the variables of the major scope. This means that minor scopes when accessed will need to account for the total variables of all previous scopes. This can be done during the generation phase as incrementing both a function size and a scope size whenever a declaration is reached, and then decrementing the function size by the scope size when leaving a scope. This allows us to place variables in overlapping locations when their execution times do not overlap.

    Example code:

    {
        var x, y[3] : integer

        {
            var z : integer
            z := z  % 1.c.1
        }

        {
            var w : integer
            w := w  % 1.c.2
        }
    }

    Generated code for access:

    ADDR 0 4    % 1.c.1

    ADDR 0 4    % 1.c.2

    These must be offset to account for the total size of the scope the main lexical scope, but they do not need to be offset relative to each other since these variables are mutually exclusive when it comes to accessibility.

    d. integer and boolean constants

    These values will not be "stored" anywhere but the program code. These constants will be embedded in the program code and will simply be pushed when needed for an expression.

    e. text constants

    Just as with the other constants, text constants will only be embedded in the program code. As text constants can only be used in the context of "write" expressions, these can be interleaved with the "write" command to reduce memory requirements.

    Example code:

    {
        write "ABC" % 1.e.1
    }

    Generated code for constant (The characters will be named as the text representation rather than their character value):

    PUSH "A"    % 1.e.1
    PRINTC      % 1.e.1
    PUSH "B"    % 1.e.1
    PRINTC      % 1.e.1
    PUSH "C"    % 1.e.1
    PRINTC      % 1.e.1

2. Expressions

    a. values of constants

    As specified in 1.d and 1.e, integer and boolean values will not truly be "accessed". When an expression requires these constants, it will simply push them directly onto the stack using the PUSH command since it takes an argument anyway.

    b. values of scalar variables

    As specified in 1.a, 1.b, and 1.c, to access the value of scalar variables we first must load the address of the variable with ADDR (for which the arguments are computed at compile time), and then we use the LOAD command to collect its value.

    Example code:

    {
        var x, y[3] : integer
        x := x  % 2.b.1
    }

    Generated code:

    ADDR 0 0    % 2.b.1
    LOAD        % 2.b.1

    At the end of this, the value to be stored in x will be at the top of stack, which we can then use for whatever next steps we need (in this example, simply assigning back to x).

    c. array elements

    The beginning of accessing array elements is the same: we first load the address of the variable with ADDR. Now we must split into two cases: 1d vs 2d arrays.

        i. 1-d arrays

        Consider array A[x] where x is the expression. In this case, we must first evaluate x. Then we subtract the lower bound for dimension 1 of x, and finally we add this offset to the address acquired from ADDR, where we can use LOAD to collect the value.

        Example code:

        {
            var y[3..10] : integer
            write y[4]  % 2.c.i.1
        }

        Generated code (including initial address access):

        ADDR 0 0    % 2.c.i.1
        PUSH 4      % 2.c.i.1 - this is simply evaluating the expression "4"
        PUSH 3      % 2.c.i.1 - value of lower bound for dimension 1
        SUB         % 2.c.i.1 - subtracts lower bound from expression value
        LOAD        % 2.c.i.1

        ii. 2-d arrays

        Consider array A[x, y] where x, y are expressions. In this case, we first evaluate x. We then subtract the lower bound for dimension 1, and also multiply by the stride of dimension 2. The reasoning for these manipulations is explained in the class slides, so I will not explain again. Continuing, we then evaluate expression y, and subtract the lower bound for dimension 2. Finally, we add these together (since they will be the top most values on the stack) as well as the array address and use LOAD to collect the value.

        Example code:

        {
            var y[3..10, 7..12] : integer
            write y[4, 11]   % 2.c.i.2
        }

        Generated code (including initial address access):

        ADDR 0 0    % 2.c.i.2
        PUSH 4      % 2.c.i.2 - evaluating expression "4"
        PUSH 3      % 2.c.i.2 - value of lower bound for dimension 1
        SUB         % 2.c.i.2
        PUSH 6      % 2.c.i.2 - stride of dimension 2
        MUL         % 2.c.i.2
        PUSH 11     % 2.c.i.2 - evaluating expression "11"
        PUSH 7      % 2.c.i.2 - value of lower bound for dimension 2
        SUB         % 2.c.i.2
        ADD         % 2.c.i.2 - add values for both dimensions
        ADD         % 2.c.i.2 - add offset to array start address
        LOAD        % 2.c.i.2
    
    As a slight optimization, for arrays with a lower bound of 0, these templates will be modified to exclude the operations of PUSHing the lower bound for the dimension and substracting, since these will simply yield the same value as the original expression.

    d. arithmetic operators

    These operations will be quite simple. Simply evaluate the expression of the left, then evaluate the expression on the right. Finally, call the appropriate operation.

    Example code:

    {
        var x, y : integer
        x := 4 + 9  % 2.d.1
    }

    Generated code:
    
    PUSH 4  % 2.d.1 - evaluate left
    PUSH 9  % 2.d.1 - evaluate right
    ADD     % 2.d.1

    The last line will be the only difference for different arithmetic operators.

    e. comparison operators

    These operators each have somewhat unique behaviour. We will rely on the explanations from 2.f.

        i. The "less than" operator and the "equal" operator

        These will perform like arithmetic operators: evaluate left, evaluate right, call operation.

        Example code:

        {
            if 4 < 5 then { % 2.e.i.1

            }
        }

        Generated code:

        PUSH 4  % 2.e.i.1
        PUSH 5  % 2.e.i.1
        LT      % 2.e.i.1

        ii. The "greater than" operator

        This operator will be similar to the previous: evaluate left, evaluate right, swap the values, call LT operation. We can do this, since if b < a, that means a > b. So simply swapping the top two values (the values of the expression) will produce the desired result.

        Example code:

        {
            if 4 > 5 then { % 2.e.ii.1

            }
        }

        Generated code:

        PUSH 4  % 2.e.ii.1
        PUSH 5  % 2.e.ii.1
        SWAP    % 2.e.ii.1
        LT      % 2.e.ii.1

        As a note, the reason we do not simply evaluate the right then the left is because if a function on the right yields some side effect to variables accessible to the left, the computation will be incorrect.

        iii. The "greater than or equal" operator, the "not equal" operator and the "less than or equal" operator

        These can simply by the boolean "not" of "less than", "equal", and "greater than" operators respectively. As described in 2.f, performing a boolean "not" is simply taking 1 - <your value> so, using the same trick, we first push a 1 onto the stack, then proceed as normal with the associated operation, and subtract at the end to perform the boolean "not".

        Example code:
        
        {
            if 4 >= 5 then { % 2.e.iii.1

            }
        }

        Generated code:

        PUSH 1  % 2.e.iii.1 - push 1 for the boolean "not" later
        PUSH 4  % 2.e.iii.1
        PUSH 5  % 2.e.iii.1
        LT      % 2.e.iii.1
        SUB     % 2.e.iii.1 - subtract for the boolean "not"

        The same can be done for "greater than" and "equal" operations to get the associated result.
    
    f. boolean operators

    The "or" operator can be performed just like the arithmetic operators: evaluate left, evaluate right, call OR command. The "and" operator is slightly more tricky (and "not" is trickier still). First we must note that boolean values are stored as 1 for true, and 0 for false. Using this fact, we can perform an "and" using addition. If both sides are true, that means that they are both 1, so adding them together will yield 2 (in any other case the sum is less than 2). We can then simply check if the sum we get equals 2, and if it does, the expression evaluates to true. Otherwise, the sum must have been less than 2, and therefore the "and" fails (as expected).

    Example code:

    {
        if true and false then {    % 2.f.1

        }
    }

    Generated code:

    PUSH 1  % 2.f.1 - evaluate left
    PUSH 0  % 2.f.1 - evaluate right
    ADD     % 2.f.1
    PUSH 2  % 2.f.1 - the 2 we will compare against
    EQ      % 2.f.1

    The "not" operation will also take advantage of the representation of the boolean values. Since true is 1, and false is 0, we can do 1 - <value> to get the boolean "not", since 1 - true = 1 - 1 = 0 = false and 1 - false = 1 - 0 = 1 = true (the expected results for "not"). To do this in our code generation, we first push a 1 (so we have something to subtract from). Then we evaluate the expression to be "not"ed and finally we subtract the two.

    Example code:

    {
        if not false then {  % 2.f.2

        }
    }

    Generated code:

    PUSH 1  % 2.f.2 - the 1 to subtract from later
    PUSH 0  % 2.f.2 - evaluate expression
    SUB     % 2.f.2

    g. conditional expressions

    Conditional expressions will use a branch command. The idea is to first evaluate the condition, and if false, jump to the part of the code that evaluates the "false" expression of the conditional. If the condition is true, it should evaluate the "true" expression. To do this, we use two branches. The first will decide whether to evaluate the "true" or "false" expressions. The second will "skip" over the false section so we do not evaluate both expressions. The difficult part is that, since we do not know how big the "true" expression will be in terms of instructions, we will have to go back (during code generation) after constructing the "true" expression to assign the correct address.

    Example code:

    {
        write (true ? 7 : 9)    % 2.g.1
    }

    Generated code:

    PUSH <address of false expression>      % 2.g.1 - for BF later
    PUSH 1                                  % 2.g.1 - evaluate condition
    BF                                      % 2.g.1
    PUSH 7                                  % 2.g.1 - evaluate true expression
    PUSH <address after false expression>   % 2.g.1 - skip over false expression
    BR                                      % 2.g.1
    PUSH 9                                  % 2.g.1 - evaluate false expression, this is the address of the false expression
    % This would be the address after false expression

3. functions and procedures

    a. the activation record

    Our activation record will be a combination of the block mark and the local variables (in that order). In addition, we add the slight simplification that the display entries will point to the start of the local variables. This allows us to easily distinguish between accessing variables, and accessing the block mark. Our block mark will contain the return address and the static link. As will be discussed in 3.g, the dynamic link can be recreated from the call site, and as the display management strategy will have to be generated at compile time, we can save on memory this way. Example code generation will be given in 3.b.

    b. procedure and function entrance code

    Both procedures and functions will essentially have the same entrance code. We have two locations to consider: the call site, and the start of the routine. First, the call site. In order to call the function we need to provide the return address and the parameters, and finally jump. We will also make space for the static link. So, we simply PUSH the return address, PUSH 0 to make a space for the static link, and then evaluate all parameter expressions in order. Finally, we PUSH the address of the routine and use BR to jump into the code.

    Example code:

    {
        procedure p(a : integer) {

        }
        p(7)   % 3.b.1
    }

    Generated code:

    PUSH <address after branch>     % 3.b.1
    PUSH 0                          % 3.b.1
    PUSH 7                          % 3.b.1 - evaluate parameter expression
    PUSH <address of procedure p>   % 3.b.1
    BR                              % 3.b.1

    Inside the routine, we must store the correct static link, update the display table and then PUSH all variables. To get the correct static link, we simply get the address of the display for the lexical level above the routine (lecture slides explain this in more detail). We then replace the 0 we PUSHed at the call site with this static link we collected. In order to replace this we will need to calculate the correct offset at compile time to subtract by which will be the number of parameters plus 1. To update the display, we simply use PUSHMT to get the current stack pointer, subtract the size of the parameters, and use SETD to set the pointer of the routine's lexical level to this stack pointer. Finally, we need to allocate space for the routine's local variables. We can do this by first PUSHing a 0, which will be the default value for all variables. We then PUSH the number of addresses we need to fill, and then use DUPN. This will fill all our desired values in at once with few commands. As a note, when using DUPN, we must not include the parameter sizes in our count as those will be handled by the callsite. In addition, if the size of local variables is less than or equal to 3 (the number of instructions it takes to perform the DUPN), we can simply replace this with 3 PUSH 0 commands. This may be an optional optimization in the future.
    
    Example code:

    {
        procedure p(a : integer) {  % 3.b.2
            var x[5] : integer
        }
        p(7)
    }

    Generated code:

    PUSHMT      % 3.b.2
    PUSH 2      % 3.b.2 - size of parameters plus one
    SUB         % 3.b.2
    ADDR 0 0    % 3.b.2 - get static link (one lexical level up)
    STORE       % 3.b.2 - store the static link in its correct location
    PUSHMT      % 3.b.2
    PUSH 1      % 3.b.2 - size of parameters
    SUB         % 3.b.2
    SETD 1      % 3.b.2
    PUSH 0      % 3.b.2
    PUSH 6      % 3.b.2 - size of remaining local variables
    DUPN        % 3.b.2 - duplicate 0 to fill the local variables.

    c. procedure and function exit code

    For exit code, procedures and functions differ. Again, we have two locations: the call site and the routine interior. The call site code will be similar for both routine types. The difference will simply be minding the added return value of functions. Once we return to the call site, we simply need to reset our display table. This will be described in more detail in 3.g, but effectively this will be a series of compile time operations which load the static links, uses SETD to assign the display for that lexical level, and then continues recursively. For the initial static link, we will simply use the current local variable sizes (plus 1, and if it is a function, plus another 1) and subtract that from our stack pointer and that will give us the initial static link (which means we do not need to store the dynamic link). Once the display is reset, we can continue on in this line of execution.

    Now the routine interior. We will consider procedures first (as they are simpler). First, when generating code for procedures, we will have the main code section, and the cleanup section. The main code will be generated from the statements of the procedure. The cleanup section will follow this, and will handle procedure exiting. So whenever a return statement is hit, we will simply push the address of the cleanup section and BR. Notice that if no return statement is hit, we will naturally move to the cleanup section (since it is after the main code).

    Example code:

    {
        procedure p {
            if true {
                return  % 3.c.1
            }
        }
        p
    }

    Generated code:

    PUSH <address of cleanup>   % 3.c.1
    BR                          % 3.c.1

    The cleanup section will simply be popping the correct number of variables off the stack, and using BR to return to the call site. To simplify code generation, we can use the display table to easily pop off the correct number of variables on the stack. For optimization, we can compute the correct number of variables to pop off and simply insert this as a constant. However for this template, we will use the first method.

    Example code:

    {
        procedure p {
            var x, y[10] : integer
            write 0
        }   % 3.c.2
        p
    }

    Generated code:

    PUSHMT      % 3.c.2
    ADDR 1 -1   % 3.c.2 - push the address of the static link, since we want to pop everything until before that.
    SUB         % 3.c.2 - this will get the number of variables on the stack from the static link to the top of the stack.
    POPN        % 3.c.2 - pop all those variables
    BR          % 3.c.2 - the return address will be next, so just branch to get back there.

    Functions have a similar idea, but we must "juggle" the return variable. Again, the code will be split into the main code and the cleanup section. On a return statement, instead of simply branching to the cleanup section, we must first evaluate the return expression, and then PUSH the cleanup address and branch. Note that in our implementation, we require that functions terminate with a return statement (they cannot reach the end of code without returning). So the cleanup section is completely separated from the main code by a return statement.

    Example code:
    
    {
        function f : integer {
            return with 7   % 3.c.3
        }
    }

    Generated code:

    PUSH 7                      % 3.c.3 - evaluate return expression
    PUSH <address of cleanup>   % 3.c.3
    BR                          % 3.c.3

    For the cleanup section, we first replace the static link with the value of the expression so that we can clear the stack. Next we use the same strategy as for procedures to clear the stack (with the added restriction that we do not pop the static link location). In order to branch, we must first SWAP the return value with the return address, after which we can use the BR command.

    Example code:
    
    {
        function f : integer {
            return with 7
        }   % 3.c.4
    }

    Generated code:

    ADDR 1 -1   % 3.c.4 - get address of the static link
    SWAP        % 3.c.4 - swap the address with the return value
    STORE       % 3.c.4
    PUSHMT      % 3.c.4
    ADDR 1 0    % 3.c.4
    SUB         % 3.c.4
    POPN        % 3.c.4
    SWAP        % 3.c.4 - swap the return value and the return address
    BR          % 3.c.4 - return to the call site.
    
