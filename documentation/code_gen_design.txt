General Design Ideas:

To simplify code generation, we simply started writing code at memory address 0. Whenever we would write an instruction, we simply incremented the "pointer" to the memory address. This made it easy to generate code in sequence. Nodes didn't need to worry about where they were writing code, only the order in which the instructions were written (which is the main concern with code generation). Some nodes, like "if" statements, required knowing the addresses of later parts of its own code generation in order to know where to "branch" to. To solve this, we would add placeholder values for these values and store the memory address corresponding to those. Once the relevant code location was generated, we would then return and replace those values with the correct ones. For most nodes, this resolved the issue and required nothing else, since the only node interested in those addresses was itself. For others, we will discuss that after.

For the main structure of our code generator, we used a tree-structure. Each AST Node generated its own code as well as recursing on subnodes in the order it requires. This meant it was easy to find malfunctioning code, and also abstracted away the content of subnodes, as long as we knew what would remain on the stack after the subnode completed. This also made the "pointer" method of writing code work very well, as subtrees wrote code sequentially after "preamble" portions of parent nodes, so the resulting code was always seamless.

Some nodes however required knowing the addresses of parent components in order to be done. For example, an exit statement in a loop needs to know the address after the loop in order to exit. To solve this, we added a stack of lists of memory addresses. Whenever a loop was entered, we would push an empty list on the stack. When an exit statement was generated, we would add a placeholder and note the memory address of it in the list corresponding to the loop we want to exit on the stack. Once a loop finished generating, we go through the list of memory addresses for that loop and fill in the correct resulting address for each.

Routines also needed their own special constructs. First, in order to layout the code nicely, we generated the code of routines in a "breadth-first" manner. That is, we started generating the main block, found all its routine declarations, finished generating the main block, and then repeat for all routines we collected. This means that in our resulting code, the routines are laid in order from top to bottom in memory as opposed to the recursive method suggested by the language.
When a call is made to the routine, we need to branch to it, so we need the starting address of the routine. To solve this we added a hashmap that took the desired routine and returned the routine address. If the routine was not in the hashmap (because it had not been generated yet), the request would be noted in a hashmap of placeholder addresses. Once a routine generated code, it would go through all these requests and replace the placeholder with the correct address of the routine. It also saves itself in the initial hashmap so future requests are immediately resolved.

Scopes were handled more simply. Instead of having the scope AST nodes handled scope initialization, we made this a more global function, since going in and out of stacks required knowing the "stack history". We used a stack of scopes. When entering a scope, the code would be generated to make enough space for the local variables. Upon exiting, these local variables were popped off. By moving this into a more global location, it was easy to see how the stack history interacted with those.

Implementation Details:

Each AST node has a performCodeGeneration method. Each node is expected to generate its own code as well as call the performCodeGeneration method on child nodes (if required).
Notably, scopes do not call performCodeGeneration on their declarations. All variable declarations are aggregated and pushed at once using DUPN on scope entry. Routine declarations are queued up to be generated later. The main code generation ends up being: dequeue the next routine to be generated and generate its code. The first thing in the queue is the main Program AST node.

Once a routine has been generated, its address is stored in CodeGen.routinePointers. At the same time, all locations that require the routine's address (to branch to) are gone through from CodeGen.awaitingRoutinePointer, and these are erased afterwards.

When entering a loop, the scope that it is currently in is stored (in CodeGen.loopStack). This way when a loop exits we know what scope to return to (and therefore how many variables to pop off). When calling exit in loops, these locations are stored in CodeGen.awaitingLoops, which are resolved when the corresponding loop is generated.