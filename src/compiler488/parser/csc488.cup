/*
    DEFINITIONS for CSC488S Source Language Winter 2016
*/

package compiler488.parser;

// TODO: You can add Java import statements here as necessary

/*
    SYMBOL LISTS

    CUP reserved words are case-sensitive and cannot be used as names of
    terminals or non-terminals. This list includes the following:

        action code extends import init left non nonassoc nonterminal package
        parser precedence right scan start super terminal with

*/

// Keyword terminals returned by the scanner (with no value attached):
terminal AND, OR, NOT, TRUE, FALSE;
terminal BOOLEAN, INTEGER, FUNCTION, PROCEDURE;
terminal DO, ELSE, EXIT, IF;
terminal READ, REPEAT, RETURN, NEWLINE, THEN, UNTIL;
terminal VAR, WHEN, WHILE, WITH, WRITE;

// Special-character terminals (with no value attached):
terminal L_PAREN, R_PAREN, L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY;
terminal EQUAL, GREATER, LESS, COMMA, DOT, QUESTION, COLON;
terminal PLUS, MINUS, TIMES, DIVIDE;

// Terminals returned by the scanner that carry a value of a specific Java type:
terminal String     IDENT;
terminal Integer    INTCONST;
terminal String     TEXTCONST;

/*
    To define non-terminals that return no value:

        nonterminal nameList;

    To define non-terminals that do return a value (think AST generation):

        nonterminal JavaType nameList;
*/

 
nonterminal	program,	statement,	declaration,	scope	;
nonterminal	statements,	declarations,	matchedStatement, unmatchedStatement ;
nonterminal	variablenames,		output			;
nonterminal	type,  	arguments,	parameters,	variable	;
nonterminal 	expression,	variablename 			;
nonterminal	inputs, outputs, bound , generalBound ;
nonterminal	procedureCall, parameter, conjunction, negation, compareExpn ;
nonterminal	arithExpn, term, factor, primary, constant ;
 

/*
    PLEASE NOTE: Your grammar may not use the 'precedence' feature of JCup to
    resolve the precedence of arithmetic operators.

    The two lines below must remain commented out;
*/

// precedence left PLUS, MINUS;
// precedence left TIMES, DIVIDE; // Higher precedence.

//  Use precedence to associate else with closest if
precedence   left ELSE ;

/*
    GRAMMAR SECTION
*/

// This specifies the initial symbol of the grammar.
start with program;

/*
    Notice that sometimes the action must be inside the production rule, not after
    it. This is a subtle yet significant difference from YACC. This is because the
    CUP parser is looking ahead one token. It ALWAYS reads one more token before it
    will act on the production.
 */

program ::= scope                           // the main program
    ;

scope
    ::= L_CURLEY declarations statements R_CURLEY   // scope with declarations and statements
    |   L_CURLEY statements R_CURLEY                // scope with statements only
    |   L_CURLEY R_CURLEY                           // empty scope
    ;

statements
    ::= statement                       // sequence of statements
    |   statements statement
    ;

declarations
    ::= declaration                     // sequence of declarations
    |   declarations declaration
    ;

statement
    ::= matchedStatement
    |   unmatchedStatement
    ;

matchedStatement
    ::= variable COLON EQUAL expression                             // assignment statement
    |   IF expression THEN matchedStatement ELSE matchedStatement   // if statements
    |   WHILE expression DO statement                               // while statement
    |   REPEAT statements UNTIL expression                           // repeat statement
    |   EXIT                                                        // exit statements
    |   EXIT INTCONST
    |   EXIT WHEN expression
    |   EXIT INTCONST WHEN expression
    |   RETURN WITH expression
    |   RETURN                                                      // return statements
    |   WRITE outputs                                               // input/output statements
    |   READ inputs
    |   procedureCall                                               // procedure call
    |   scope                                                       // embedded scope
    ;

unmatchedStatement
    ::= IF expression THEN statement
    |   IF expression THEN matchedStatement ELSE unmatchedStatement
    ;

procedureCall
    ::= IDENT                                       // call procedure with no parameters
    |   IDENT L_PAREN arguments R_PAREN             // call procedure with parameters
    ;

declaration
    ::= VAR variablenames COLON type                                // declare scalar/array variables
    | FUNCTION IDENT COLON type scope                               // declare function
    | FUNCTION IDENT L_PAREN parameters R_PAREN COLON type scope
    | PROCEDURE IDENT scope                                         // declare procedure
    | PROCEDURE IDENT L_PAREN parameters R_PAREN scope
    ;

variablenames
    ::= variablename                                // list of variables being declared
    |   variablenames COMMA variablename
    ;

variablename
    ::= IDENT                                       // scalar variable
    |   IDENT L_SQUARE bound R_SQUARE               // 1-dimension array variable
    |   IDENT L_SQUARE bound COMMA bound R_SQUARE   // 2-dimensional array variable
    ;

bound
    ::= INTCONST                                    // positive array bound
    |   generalBound DOT DOT generalBound           // upper and lower bounds
    ;

generalBound
    ::= INTCONST                    // positive integer bounds
    |   MINUS INTCONST              // negative integer bounds
    ;

type
    ::= INTEGER                     // integer type
    |   BOOLEAN                     // boolean type
    ;

outputs
    ::= output                      // list of output expressions
    |   outputs COMMA output
    ;

output
    ::= expression                  // integer expression
    |   TEXTCONST                   // text constant
    |   NEWLINE                     // newline constant
    ;

inputs
    ::= variable                    // list of variables being read into
    |   inputs COMMA variable
    ;

arguments
    ::= expression                  // list of function/procedure arguments
    |   arguments COMMA expression
    ;

parameters
    ::= parameter                   // list of function/procedure formal parameters
    |   parameters COMMA parameter
    ;

parameter
    ::= IDENT COLON type            // declare one parameter
    ;

expression
    ::= conjunction:c {: RESULT = c; :}                 // disjunctions, associate left-to-right
    |   expression:e OR conjunction:c {: RESULT = new BoolExpn(BoolExpn.OP_OR, e, c); :}
    ;

conjunction
    ::= negation:e {: RESULT = e; :}                    // conjunctions, associate left-to-right
    |   conjunction:e AND negation:n {: RESULT = new BoolExpn(BoolExpn.OP_AND, e, n); :}
    ;

negation
    ::= compareExpn:e {: RESULT = e; :}                 // negations
    |   NOT negation:e {: RESULT = new NotExpn(e); :}
    ;

compareExpn
    ::= arithExpn:e {: RESULT = e; :}                                   // comparisons, do not associate
    |   arithExpn:e1 EQUAL arithExpn:e2 {: RESULT = new EqualsExpn(EqualsExpn.OP_EQUAL, e1, e2); :}
    |   arithExpn:e1 NOT EQUAL arithExpn:e2 {: RESULT = new EqualsExpn(EqualsExpn.OP_NOT_EQUAL, e1, e2); :}
    |   arithExpn:e1 LESS arithExpn:e2 {: RESULT = new CompareExpn(CompareExpn.OP_LESS, e1, e2); :}
    |   arithExpn:e1 LESS EQUAL arithExpn:e2 {: RESULT = new CompareExpn(CompareExpn.OP_LESS_EQUAL, e1, e2); :}
    |   arithExpn:e1 GREATER arithExpn:e2 {: RESULT = new CompareExpn(CompareExpn.OP_GREATER, e1, e2); :}
    |   arithExpn:e1 GREATER EQUAL arithExpn:e2 {: RESULT = new CompareExpn(CompareExpn.OP_GREATER_EQUAL, e1, e2); :}
    ;

arithExpn
    ::= term:t {: RESULT = t; :}                        // expressions, associate + , - left-to-right
    |   arithExpn:e PLUS term:t {: RESULT = new ArithExpn(ArithExpn.OP_PLUS, e, t); :}
    |   arithExpn:e MINUS term:t {: RESULT = new ArithExpn(ArithExpn.OP_MINUS, e, t); :}
    ;

term
    ::= factor:f {: RESULT = f; :}                      // terms, associate * , / left-to-right
    |   term:t TIMES factor:f {: RESULT = new ArithExpn(ArithExpn.OP_TIMES, t, f); :}
    |   term:t DIVIDE factor:f {: RESULT = new ArithExpn(ArithExpn.OP_DIVIDE, t, f); :}
    ;

factor
    ::= primary:p {: RESULT = p; :}                     // unary minus
    |   MINUS factor:f {: RESULT = new UnaryMinusExpn(f); :}
    ;

primary
    ::= constant:c {: RESULT = c; :}                                        // integer or boolean constant
    |   variable:v {: RESULT = v; :}                                        // scalar, array variable or function call
    |   IDENT:i L_PAREN arguments:a R_PAREN                                 // function call
            {: RESULT = new FunctionCallExpn(i, a); :}
    |   L_PAREN expression:e R_PAREN {: RESULT = e; :}                      // parenthesized expression
    |   L_PAREN expression:q QUESTION expression:t COLON expression:f R_PAREN     // conditional expression
            {: RESULT = new CondtionalExpn(q, t, f); :}
    ;

constant
    ::= INTCONST:i {: RESULT = new IntConstExpn(i); :}                      // integer constant
    |   TRUE {: RESULT = new BoolConstExpn(true); :}                        // constant true
    |   FALSE {: RESULT = new BoolConstExpn(false); :}                      // constant false
    ;

variable
    ::= IDENT:i {: RESULT = new IdentExpn(i); :}                            // scalar variable or function call
    |   IDENT:arr L_SQUARE expression:i1 R_SQUARE {: RESULT = new SubsExpn(arr, i1); :} // element of 1-dimensional array
    |   IDENT:arr L_SQUARE expression:i1 COMMA expression:i2 R_SQUARE                 // element of 2-dimensional array;
            {: RESULT = new SubsExpn(arr, i1, i2); :}
    ;
