/*
    DEFINITIONS for CSC488S Source Language Winter 2016
*/

package compiler488.parser;

import compiler488.ast.*;
import compiler488.ast.expn.*;
import compiler488.ast.decl.*;
import compiler488.ast.stmt.*;
import compiler488.ast.type.*;
// TODO: You can add Java import statements here as necessary

/*
    SYMBOL LISTS

    CUP reserved words are case-sensitive and cannot be used as names of
    terminals or non-terminals. This list includes the following:

        action code extends import init left non nonassoc nonterminal package
        parser precedence right scan start super terminal with

*/

// Keyword terminals returned by the scanner (with no value attached):
terminal AND, OR, NOT, TRUE, FALSE;
terminal BOOLEAN, INTEGER, FUNCTION, PROCEDURE;
terminal DO, ELSE, EXIT, IF;
terminal READ, REPEAT, RETURN, NEWLINE, THEN, UNTIL;
terminal VAR, WHEN, WHILE, WITH, WRITE;

// Special-character terminals (with no value attached):
terminal L_PAREN, R_PAREN, L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY;
terminal EQUAL, GREATER, LESS, COMMA, DOT, QUESTION, COLON;
terminal PLUS, MINUS, TIMES, DIVIDE;

// Terminals returned by the scanner that carry a value of a specific Java type:
terminal String     IDENT;
terminal Integer    INTCONST;
terminal String     TEXTCONST;

/*
    To define non-terminals that return no value:

        nonterminal nameList;

    To define non-terminals that do return a value (think AST generation):

        nonterminal JavaType nameList;
*/

 
nonterminal	Program program; 
nonterminal Stmt statement;	
nonterminal Declaration declaration;
nonterminal	Scope scope;

nonterminal	ASTList<Stmt> statements;	
nonterminal ASTList<Declaration> declarations;	

nonterminal Stmt matchedStatement; 
nonterminal Stmt unmatchedStatement;

nonterminal	ASTList<DeclarationPart> variablenames;		
nonterminal DeclarationPart variablename;

nonterminal ASTList<Printable> outputs; 
nonterminal Printable output;

nonterminal	Type type;	

nonterminal ASTList<ScalarDecl> parameters;
nonterminal ScalarDecl parameter;

nonterminal ASTList<Expn> arguments;
nonterminal Expn expression; 
nonterminal Expn variable;

nonterminal	ASTList<Readable> inputs; 

nonterminal Integer[] bound; 
nonterminal Integer generalBound;
nonterminal	ProcedureCallStmt procedureCall; 

nonterminal Expn conjunction; 
nonterminal Expn negation;

nonterminal Expn compareExpn;
nonterminal	Expn arithExpn; 
nonterminal Expn term; 
nonterminal Expn factor; 
nonterminal Expn primary; 
nonterminal Expn constant;
 

/*
    PLEASE NOTE: Your grammar may not use the 'precedence' feature of JCup to
    resolve the precedence of arithmetic operators.

    The two lines below must remain commented out;
*/

// precedence left PLUS, MINUS;
// precedence left TIMES, DIVIDE; // Higher precedence.

//  Use precedence to associate else with closest if
precedence   left ELSE ;

/*
    GRAMMAR SECTION
*/

// This specifies the initial symbol of the grammar.
start with program;

/*
    Notice that sometimes the action must be inside the production rule, not after
    it. This is a subtle yet significant difference from YACC. This is because the
    CUP parser is looking ahead one token. It ALWAYS reads one more token before it
    will act on the production.
 */

program ::= scope:scope                             // the main program
                {: RESULT = new Program(scope); :}
    ;

scope
    ::= L_CURLEY declarations:decls statements:stmts R_CURLEY   // scope with declarations and statements
            {: RESULT = new Scope(decls, stmts); :}
    |   L_CURLEY statements:stmts R_CURLEY                      // scope with statements only
            {: RESULT = new Scope(null, stmts); :}
    |   L_CURLEY R_CURLEY                                       // empty scope
            {: RESULT = new Scope(null, null); :}
    ;

statements
    ::= statement:stmt                          // sequence of statements
            {: RESULT = new ASTList(stmt); :}
    |   statements:stmt_list statement:stmt
            {: RESULT = stmt_list.append(stmt); :}
    ;

declarations
    ::= declaration:d                           // sequence of declarations
            {: RESULT = new ASTList(d); :}
    |   declarations:dcl_list declaration:d
            {: RESULT = dcl_list.append(d); :}
    ;

statement
    ::= matchedStatement:stmt
            {: RESULT = stmt; :}
    |   unmatchedStatement:stmt
            {: RESULT = stmt; :}
    ;

matchedStatement
    ::= variable:v COLON EQUAL expression:e                             // assignment statement
            {: RESULT = new AssignStmt(v, e); :}
    |   IF expression:e THEN matchedStatement:true_stmt ELSE matchedStatement:false_stmt   // if statements
            {: RESULT = new IfStmt(e, true_stmt, false_stmt); :}
    |   WHILE expression:e DO statement:stmt                        // while statement
            {: RESULT = new WhileDoStmt(e, new ASTList(stmt)); :}
    |   REPEAT statements:stmt_list UNTIL expression:e              // repeat statement
            {: RESULT = new RepeatUntilStmt(e, stmt_list); :}
    |   EXIT                                                         // exit statements
            {: RESULT = new ExitStmt(); :}
    |   EXIT INTCONST:i
            {: RESULT = new ExitStmt(i); :}
    |   EXIT WHEN expression:e
            {: RESULT = new ExitStmt(e); :}
    |   EXIT INTCONST:i WHEN expression:e
            {: RESULT = new ExitStmt(i, e); :}
    |   RETURN WITH expression:e
            {: RESULT = new ReturnStmt(e); :}
    |   RETURN                                                      // return statements
            {: RESULT = new ReturnStmt(); :}
    |   WRITE outputs:o_list                                        // input/output statements
            {: RESULT = new WriteStmt(o_list); :}
    |   READ inputs:i_list
            {: RESULT = new ReadStmt(i_list); :}
    |   procedureCall:p                                               // procedure call
            {: RESULT = p; :}
    |   scope:scope                                                   // embedded scope
            {: RESULT = scope; :}
    ;

unmatchedStatement
    ::= IF expression:cond THEN statement:stmt_true
            {: RESULT = new IfStmt(cond, stmt_true); :}
    |   IF expression:cond THEN matchedStatement:stmt_true ELSE unmatchedStatement:stmt_false
            {: RESULT = new IfStmt(cond, stmt_true, stmt_false); :}
    ;

procedureCall
    ::= IDENT:i                                     // call procedure with no parameters
            {: RESULT = new ProcedureCallStmt(i); :}  
    |   IDENT:i L_PAREN arguments:a R_PAREN             // call procedure with parameters
            {: RESULT = new ProcedureCallStmt(i, a); :}
    ;

declaration
    ::= VAR variablenames:var_list COLON type:t                     // declare scalar/array variables
            {: RESULT = new MultiDeclarations(t, var_list); :}
    | FUNCTION IDENT:f_name COLON type:t scope:body                 // declare function
            {: RESULT = new RoutineDecl(f_name, t, body); :}
    | FUNCTION IDENT:f_name L_PAREN parameters:param_list R_PAREN COLON type:t scope:body
            {: RESULT = new RoutineDecl(f_name, t, param_list, body); :}
    | PROCEDURE IDENT:p_name scope:body                             // declare procedure
            {: RESULT = new RoutineDecl(p_name, body); :}
    | PROCEDURE IDENT:p_name L_PAREN parameters:param_list R_PAREN scope:body
            {: RESULT = new RoutineDecl(p_name, param_list, body); :}
    ;

variablenames
    ::= variablename:v                                // list of variables being declared
            {: RESULT = new ASTList(v); :}
    |   variablenames:var_list COMMA variablename:v
            {: RESULT = var_list.append(v); :}
    ;

variablename
    ::= IDENT:i                                                  // scalar variable
            {: RESULT = new ScalarDeclPart(i); :}
    |   IDENT:arr1d L_SQUARE bound:b1 R_SQUARE                   // 1-dimension array variable
            {: RESULT = new ArrayDeclPart(arr1d, b1[0], b1[1]); :}
    |   IDENT:arr2d L_SQUARE bound:b1 COMMA bound:b2 R_SQUARE    // 2-dimensional array variable
            {: RESULT = new ArrayDeclPart(arr2d, b1[0], b1[1], b2[0], b2[1]); :}
    ;

bound
    ::= INTCONST:i                                  // positive array bound
            {: RESULT = new Integer[] {1, i}; :}
    |   generalBound:lb DOT DOT generalBound:ub     // upper and lower bounds
            {: RESULT = new Integer[] {lb, ub}; :}
    ;

generalBound
    ::= INTCONST:i                    // positive integer bounds
            {: RESULT = i; :}
    |   MINUS INTCONST:i              // negative integer bounds
            {: RESULT = -i; :}
    ;

type
    ::= INTEGER:i                     // integer type
            {: RESULT = new IntegerType(); :}
    |   BOOLEAN:b                     // boolean type
            {: RESULT = new BooleanType(); :}
    ;

outputs
    ::= output:o                      // list of output expressions
            {: RESULT = new ASTList(o); :}
    |   outputs:o_list COMMA output:o
            {: RESULT = o_list.append(o); :}
    ;

output
    ::= expression:e                  // integer expression
            {: RESULT = e; :}
    |   TEXTCONST:t                   // text constant
            {: RESULT = new TextConstExpn(t); :}
    |   NEWLINE:n                     // newline constant
            {: RESULT = new SkipConstExpn(); :}
    ;

inputs
    ::= variable:v                    // list of variables being read into
            {: RESULT = new ASTList(v); :}
    |   inputs:v_list COMMA variable:v
            {: RESULT = v_list.append(v); :}
    ;

arguments
    ::= expression:e                  // list of function/procedure arguments
            {: RESULT = new ASTList(e); :}
    |   arguments:a_list COMMA expression:e
            {: RESULT = a_list.append(e); :}
    ;

parameters
    ::= parameter:p                   // list of function/procedure formal parameters
            {: RESULT = new ASTList<ScalarDecl>(p); :}
    |   parameters:p_list COMMA parameter:p
            {: RESULT = p_list.append(p); :}
    ;

parameter
    ::= IDENT:i COLON type:t            // declare one parameter
            {: RESULT = new ScalarDecl(i, t); :}
    ;

expression
    ::= conjunction:c {: RESULT = c; :}                 // disjunctions, associate left-to-right
    |   expression:e OR conjunction:c {: RESULT = new BoolExpn(BoolExpn.OP_OR, e, c); :}
    ;

conjunction
    ::= negation:e {: RESULT = e; :}                    // conjunctions, associate left-to-right
    |   conjunction:e AND negation:n {: RESULT = new BoolExpn(BoolExpn.OP_AND, e, n); :}
    ;

negation
    ::= compareExpn:e {: RESULT = e; :}                 // negations
    |   NOT negation:e {: RESULT = new NotExpn(e); :}
    ;

compareExpn
    ::= arithExpn:e {: RESULT = e; :}                                   // comparisons, do not associate
    |   arithExpn:e1 EQUAL arithExpn:e2 {: RESULT = new EqualsExpn(EqualsExpn.OP_EQUAL, e1, e2); :}
    |   arithExpn:e1 NOT EQUAL arithExpn:e2 {: RESULT = new EqualsExpn(EqualsExpn.OP_NOT_EQUAL, e1, e2); :}
    |   arithExpn:e1 LESS arithExpn:e2 {: RESULT = new CompareExpn(CompareExpn.OP_LESS, e1, e2); :}
    |   arithExpn:e1 LESS EQUAL arithExpn:e2 {: RESULT = new CompareExpn(CompareExpn.OP_LESS_EQUAL, e1, e2); :}
    |   arithExpn:e1 GREATER arithExpn:e2 {: RESULT = new CompareExpn(CompareExpn.OP_GREATER, e1, e2); :}
    |   arithExpn:e1 GREATER EQUAL arithExpn:e2 {: RESULT = new CompareExpn(CompareExpn.OP_GREATER_EQUAL, e1, e2); :}
    ;

arithExpn
    ::= term:t {: RESULT = t; :}                        // expressions, associate + , - left-to-right
    |   arithExpn:e PLUS term:t {: RESULT = new ArithExpn(ArithExpn.OP_PLUS, e, t); :}
    |   arithExpn:e MINUS term:t {: RESULT = new ArithExpn(ArithExpn.OP_MINUS, e, t); :}
    ;

term
    ::= factor:f {: RESULT = f; :}                      // terms, associate * , / left-to-right
    |   term:t TIMES factor:f {: RESULT = new ArithExpn(ArithExpn.OP_TIMES, t, f); :}
    |   term:t DIVIDE factor:f {: RESULT = new ArithExpn(ArithExpn.OP_DIVIDE, t, f); :}
    ;

factor
    ::= primary:p {: RESULT = p; :}                     // unary minus
    |   MINUS factor:f {: RESULT = new UnaryMinusExpn(f); :}
    ;

primary
    ::= constant:c {: RESULT = c; :}                                        // integer or boolean constant
    |   variable:v {: RESULT = v; :}                                        // scalar, array variable or function call
    |   IDENT:i L_PAREN arguments:a R_PAREN                                 // function call
            {: RESULT = new FunctionCallExpn(i, a); :}
    |   L_PAREN expression:e R_PAREN {: RESULT = e; :}                      // parenthesized expression
    |   L_PAREN expression:q QUESTION expression:t COLON expression:f R_PAREN     // conditional expression
            {: RESULT = new ConditionalExpn(q, t, f); :}
    ;

constant
    ::= INTCONST:i {: RESULT = new IntConstExpn(i); :}                      // integer constant
    |   TRUE {: RESULT = new BoolConstExpn(true); :}                        // constant true
    |   FALSE {: RESULT = new BoolConstExpn(false); :}                      // constant false
    ;

variable
    ::= IDENT:i {: RESULT = new IdentExpn(i); :}                            // scalar variable or function call
    |   IDENT:arr L_SQUARE expression:i1 R_SQUARE {: RESULT = new SubsExpn(arr, i1); :} // element of 1-dimensional array
    |   IDENT:arr L_SQUARE expression:i1 COMMA expression:i2 R_SQUARE                 // element of 2-dimensional array;
            {: RESULT = new SubsExpn(arr, i1, i2); :}
    ;
