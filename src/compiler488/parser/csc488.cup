/*
    DEFINITIONS for CSC488S Source Language Winter 2016
*/

package compiler488.parser;

// TODO: You can add Java import statements here as necessary

/*
    SYMBOL LISTS

    CUP reserved words are case-sensitive and cannot be used as names of
    terminals or non-terminals. This list includes the following:

        action code extends import init left non nonassoc nonterminal package
        parser precedence right scan start super terminal with

*/

// Keyword terminals returned by the scanner (with no value attached):
terminal AND, OR, NOT, TRUE, FALSE;
terminal BOOLEAN, INTEGER, FUNCTION, PROCEDURE;
terminal DO, ELSE, EXIT, IF;
terminal READ, REPEAT, RETURN, NEWLINE, THEN, UNTIL;
terminal VAR, WHEN, WHILE, WITH, WRITE;

// Special-character terminals (with no value attached):
terminal L_PAREN, R_PAREN, L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY;
terminal EQUAL, GREATER, LESS, COMMA, DOT, QUESTION, COLON;
terminal PLUS, MINUS, TIMES, DIVIDE;

// Terminals returned by the scanner that carry a value of a specific Java type:
terminal String     IDENT;
terminal Integer    INTCONST;
terminal String     TEXTCONST;

/*
    To define non-terminals that return no value:

        nonterminal nameList;

    To define non-terminals that do return a value (think AST generation):

        nonterminal JavaType nameList;
*/

 
nonterminal	program,	statement,	declaration,	scope	;
nonterminal	statements,	declarations,	matchedStatement, unmatchedStatement ;
nonterminal	variablenames,		output			;
nonterminal	type,  	arguments,	parameters,	variable	;
nonterminal 	expression,	variablename 			;
nonterminal	inputs, outputs, bound , generalBound ;
nonterminal	procedureCall, parameter, conjunction, negation, compareExpn ;
nonterminal	arithExpn, term, factor, primary, constant ;
 

/*
    PLEASE NOTE: Your grammar may not use the 'precedence' feature of JCup to
    resolve the precedence of arithmetic operators.

    The two lines below must remain commented out;
*/

// precedence left PLUS, MINUS;
// precedence left TIMES, DIVIDE; // Higher precedence.

//  Use precedence to associate else with closest if
precedence   left ELSE ;

/*
    GRAMMAR SECTION
*/

// This specifies the initial symbol of the grammar.
start with program;

/*
    Notice that sometimes the action must be inside the production rule, not after
    it. This is a subtle yet significant difference from YACC. This is because the
    CUP parser is looking ahead one token. It ALWAYS reads one more token before it
    will act on the production.
 */

program ::= scope                           // the main program
    ;

scope
    ::= L_CURLEY declarations statements R_CURLEY   // scope with declarations and statements
    |   L_CURLEY statements R_CURLEY                // scope with statements only
    |   L_CURLEY R_CURLEY                           // empty scope
    ;

statements
    ::= statement                       // sequence of statements
    |   statements statement
    ;

declarations
    ::= declaration                     // sequence of declarations
    |   declarations declaration
    ;

statement
    ::= matchedStatement
    |   unmatchedStatement
    ;

matchedStatement
    ::= variable COLON EQUAL expression                             // assignment statement
    |   IF expression THEN matchedStatement ELSE matchedStatement   // if statements
    |   WHILE expression DO statement                               // while statement
    |   REPEAT statements UNTIL expression                           // repeat statement
    |   EXIT                                                        // exit statements
    |   EXIT INTCONST
    |   EXIT WHEN expression
    |   EXIT INTCONST WHEN expression
    |   RETURN WITH expression
    |   RETURN                                                      // return statements
    |   WRITE outputs                                               // input/output statements
    |   READ inputs
    |   procedureCall                                               // procedure call
    |   scope                                                       // embedded scope
    ;

unmatchedStatement
    ::= IF expression THEN statement
    |   IF expression THEN matchedStatement ELSE unmatchedStatement
    ;

procedureCall
    ::= IDENT                                       // call procedure with no parameters
    |   IDENT L_PAREN arguments R_PAREN             // call procedure with parameters
    ;

declaration
    ::= VAR variablenames COLON type                                // declare scalar/array variables
    | FUNCTION IDENT COLON type scope                               // declare function
    | FUNCTION IDENT L_PAREN parameters R_PAREN COLON type scope
    | PROCEDURE IDENT scope                                         // declare procedure
    | PROCEDURE IDENT L_PAREN parameters R_PAREN scope
    ;

variablenames
    ::= variablename                                // list of variables being declared
    |   variablenames COMMA variablename
    ;

variablename
    ::= IDENT                                       // scalar variable
    |   IDENT L_SQUARE bound R_SQUARE               // 1-dimension array variable
    |   IDENT L_SQUARE bound COMMA bound R_SQUARE   // 2-dimensional array variable
    ;

bound
    ::= INTCONST                                    // positive array bound
    |   generalBound DOT DOT generalBound           // upper and lower bounds
    ;

generalBound
    ::= INTCONST                    // positive integer bounds
    |   MINUS INTCONST              // negative integer bounds
    ;

type
    ::= INTEGER                     // integer type
    |   BOOLEAN                     // boolean type
    ;

outputs
    ::= output                      // list of output expressions
    |   outputs COMMA output
    ;

output
    ::= expression                  // integer expression
    |   TEXTCONST                   // text constant
    |   NEWLINE                     // newline constant
    ;

inputs
    ::= variable                    // list of variables being read into
    |   inputs COMMA variable
    ;

arguments
    ::= expression                  // list of function/procedure arguments
    |   arguments COMMA expression
    ;

parameters
    ::= parameter                   // list of function/procedure formal parameters
    |   parameters COMMA parameter
    ;

parameter
    ::= IDENT COLON type            // declare one parameter
    ;

expression
    ::= conjunction                 // disjunctions, associate left-to-right
    |   expression OR conjunction
    ;

conjunction
    ::= negation                    // conjunctions, associate left-to-right
    |   conjunction AND negation
    ;

negation
    ::= compareExpn                 // negations
    |   NOT negation
    ;

compareExpn
    ::= arithExpn                                   // comparisons, do not associate
    |   arithExpn EQUAL arithExpn
    |   arithExpn NOT EQUAL arithExpn
    |   arithExpn LESS arithExpn
    |   arithExpn LESS EQUAL arithExpn
    |   arithExpn GREATER arithExpn
    |   arithExpn GREATER EQUAL arithExpn
    ;

arithExpn
    ::= term                        // expressions, associate + , - left-to-right
    |   arithExpn PLUS term
    |   arithExpn MINUS term
    ;

term
    ::= factor                      // terms, associate * , / left-to-right
    |   term TIMES factor
    |   term DIVIDE factor
    ;

factor
    ::= primary                     // unary minus
    |   MINUS factor
    ;

primary
    ::= constant                                                            // integer or boolean constant
    |   variable                                                            // scalar, array variable or function call
    |   IDENT L_PAREN arguments R_PAREN                                     // function call
    |   L_PAREN expression R_PAREN                                          // parenthesized expression
    |   L_PAREN expression QUESTION expression COLON expression R_PAREN     // conditional expression
    ;

constant
    ::= INTCONST                    // integer constant
    |   TRUE                        // constant true
    |   FALSE                       // constant false
    ;

variable
    ::= IDENT                                                               // scalar variable or function call
    |   IDENT L_SQUARE expression R_SQUARE                                  // element of 1-dimensional array
    |   IDENT L_SQUARE expression COMMA expression R_SQUARE                 // element of 2-dimensional array;
    ;
